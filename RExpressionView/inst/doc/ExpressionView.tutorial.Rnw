% \VignetteIndexEntry{ExpressionView}
\documentclass{article}
\usepackage{ragged2e}
\usepackage{hyperref}
\usepackage{url}
\usepackage[margin=3cm]{geometry}

\newcommand{\Rfunction}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\texttt{#1}}
\newcommand{\Rclass}[1]{\texttt{#1}}
\newcommand{\Rargument}[1]{\textsl{#1}}
\newcommand{\filename}[1]{\texttt{#1}}
\newcommand{\variable}[1]{\texttt{#1}}

%\SweaveOpts{prefix.string=graphics/plot}

\begin{document}

\title{ExpressionView}
\author{Andreas L\"uscher}
\maketitle

\tableofcontents

\RaggedRight

<<set width,echo=FALSE,print=FALSE>>=
options(width=60)
options(continue=" ")
@ 

\section{Introduction}
Clustering genes according to their expression profiles is an important task 
in analyzing microarray data. In this tutorial, we explain how to use ExpressionView, 
an R package designed to interactively explore biclusters identified in gene 
expression data in conjunction with the Iterative Signature Algorithm (ISA)~\cite{bergmann03} 
and the biclustering methods available in the \Rpackage{Biclust} package~\cite{kaiser08}.

\section{Loading the gene expression data}
The \Rpackage{ExpressionView} package requires the gene expression data to be available in the
form of a \Rpackage{Bioconductor} \Rclass{ExpressionSet}. In this tutorial we will use the 
\Rpackage{Bioconductor} sample data from a 
clinical trial in acute lymphoblastic leukemia provided by the \Rpackage{ALL} package.
<<load the data>>=
library(ALL)
library(hgu95av2.db)
data(ALL)
@
The data set contains \Sexpr{ncol(ALL)} samples and \Sexpr{nrow(ALL)} features.

\section{Find biclusters}
There are many biclustering algorithms described in the literature~\cite{madeira04}.
All of them aim to reduce the complexity of the gene expression data by identifying 
suitable groups of genes and conditions that are co-regulated. In what follows we
show how to use two of the freely available biclustering methods.

\subsection{Iterative Signature Algorithm (ISA)}
The ISA~\cite{bergmann03} for gene expression data is implemented in the \Rpackage{eisa} package:
<<load the packages>>=
library(eisa)
@

To run the ISA for the given data set, simply call the \Rfunction{ISA} function on the
\Rclass{ExpressionSet} object:
<<ISA, eval=FALSE>>=
set.seed(5) # initialize random number generator to get always the same results
modules <- ISA(ALL)
@ 
Depending on your computing resources, this should take roughly two minutes. If you do not
want to wait that long, you can shorten the calculation by selecting the thresholds for genes and
conditions:
<<fast ISA, cache=FALSE>>=
threshold.genes <- 2.7 
threshold.conditions <- 1.4 
set.seed(5)
modules <- ISA(ALL, thr.gene=threshold.genes, thr.cond=threshold.conditions)
@
If you leave the thresholds undefined, as in the first example, the ISA runs with the 
default values, i.e., \variable{thr.gene=c(2,2.5,3,3.5,4)} and \variable{thr.cond=c(1,1.5,2,2.5,3)}.
In both cases, the random number generator is initialized manually using \Rfunction{set.seed(5)}, 
to give reproducible results. The \Rfunction{isa} function returns an \Rclass{ISAModules} object. 
Typing its name returns a brief summary of the results:
<<ISAModules summary>>=
modules
@

The ISA biclustering is not binary, every gene (and
similarly, every sample or condition) has a score between -1 and 1; the further the
score is from zero, the stronger the association between the gene
(or sample) and the module. If two features both have scores with the
same sign, they are correlated, otherwise, they are anti-correlated.

\subsection{Algorithms of the \Rpackage{Biclust} package}
The \Rpackage{biclust} package implements several biclustering
algorithms in a unified framework. It uses the \Rclass{Biclust} class 
to store a set of biclusters. Let us use the Plaid Model Bicluster Algorithm~\cite{turner04}
on the \Rpackage{ALL} data set
<<biclust bcplaid,cache=FALSE>>=
library(biclust)
biclusters <- biclust(exprs(ALL), BCPlaid(), fit.model = ~m + a + b, verbose = FALSE)
@

The standard R function \Rfunction{as} 
can be used to convert \Rclass{ISAModules} to \Rclass{Biclust} objects. This
requires the binarization of the modules, i.e., the ISA scores are
lost since they are converted to zeros and ones:
<<biclust>>=
as(modules, "Biclust")
@

The conversion also works in the other direction. Starting from a \Rclass{Biclust} object, just use
<<isa>>=
as(biclusters, "ISAModules")
@
to get an \Rclass{ISAModules} object.

\subsection{External clustering programs}
Since the structure of biclustering results is independent of the applied method, it is straightforward to
import results obtained from external clustering programs and convert them to \Rclass{ISAModules}.
To illustrate the conversion, let us consider the sample data and {\bf randomly} assign the  \Sexpr{nrow(ALL)} genes 
and  \Sexpr{ncol(ALL)} samples to  \Sexpr{length(modules)} modules. The resulting modules can be described by two
binary matrices
<<random-modules>>=
modules.genes <- matrix(as.integer(runif(dim(ALL)[1]*length(modules),0,1)>0.8),nrow=dim(ALL)[1])
modules.conditions <- matrix(as.integer(runif(dim(ALL)[2]*length(modules),0,1)>0.8),nrow=dim(ALL)[2])
@
indicating if a given gene \variable{i} is contained in module \variable{j} if \variable{modules.genes[i,j]$\ne$0}.
Using these matrices, it is straightforward to create an \Rclass{ISAModules} object:
<<toisa>>=
new("ISAModules",
genes=modules.genes, conditions=modules.conditions,rundata=data.frame(),seeddata=data.frame())
@

\section{Order}
To present the tens of possibly overlapping biclusters in a visually appealing form, 
it is necessary to regroup the rows and columns of the gene expression matrix in 
such a way that biclusters form contiguous rectangles. Since for more than two 
mutually overlapping biclusters, it is in general impossible to find such an arrangement,
 one has to make concessions. In contrast to~\cite{grothaus06}, who proposed to repeat 
 rows and columns as necessary to achieve this goal, we prefer to optimize the 
 arrangement within the original data by maximizing the area of the largest contiguous biclusters. 

The \Rfunction{OrderEV} function implemented in the \Rpackage{ExpressionView} package
determines the optimal order of the gene expression matrix for a given set of biclusters:
<<expressionview, results=HIDE>>=
library(ExpressionView)
optimalorder <- OrderEV(modules)
@

The result is a list containing various mappings between the original data and the optimal arrangement.
Note that the genes and the samples can be ordered separately. Apart form reordering the 
full gene expression matrix, the algorithm also determines the best arrangement of individual biclusters.
The mapping of the genes and the samples contained in bicluster \variable{i} can be accessed by 
<<gene maps, eval=FALSE>>=
optimalorder$genes[i+1]
optimalorder$samples[i+1]
@
Here, \variable{i=0}, returns the map of the complete data set. By default, the \Rfunction{OrderEV}
runs for roughly one minute, this might not be sufficient to find an appropriate order for data 
containing many overlapping biclusters. The status of the ordering is stored in 
<<status ordering>>=
optimalorder$status
@
If the status is set to \variable{1}, the algorithm has found the optimal solution. A \variable{0} indicates that the
the calculation could not be terminated within the given timeframe. The \Rfunction{OrderEV} 
accepts two additional parameters to circumvent the problem of partial alignment:
One can start the ordering from a given initial configuration, i.e., the result of a previous arrangement
by defining the \Rargument{initialorder} argument
<<status ordering, eval=FALSE>>=
optimalorderp <- OrderEV(modules, initialorder=optimalorder, maxtime=120)
@
and one can increase the time limit by specifying \Rargument{maxtime}. Note that the time is indicated in seconds
and cannot be  smaller than 1.

\section{Export}
The \Rfunction{ExportEV} function allows the user to combine the available data and export it to an XML file that can be read by the Flash applet:
<<export, eval=FALSE>>=
ExportEV(modules, ALL, optimalorder, filename="file.evf")
@
The function gathers the data contained in the \Rclass{ExpressionSet} \variable{ALL}, orders it according to the optimal arrangement 
\variable{optimalorder} and adds the biclusters defined in \variable{modules}. The output is an uncompressed XML file that can be opened with any text viewer. We have chosen to use the extension \variable{.evf} (for ExpressionView file) for the data files. This extension is associated with the stand-alone version of the viewer, so that one can simply double-click on such a file to launch the program and load the data. The file association is the reason why we do not use the \variable{.xml} extension. A description of the XML layout can be found on the  href{http://www2.unil.ch/cbg/index.php?title=ExpressionView}{website}. Before exporting the data, the 
\Rfunction{ExportEV} function automatically calculates GO~\cite{ashburner00} and KEGG~\cite{kanehisa04} enrichments for the given biclusters.

\section{Visualize}
The ExpressionView Flash applet can be launched from the R environment:
<<export, eval=FALSE>>=
OpenEV()
@
Video tutorials describing how to use the applet can be found on the ExpressionView \\
\href{http://www2.unil.ch/cbg/index.php?title=ExpressionView}{website}.

\section{Session information}

The version number of R and packages loaded for generating this
vignette were:

<<sessioninfo,results=tex,echo=FALSE>>=
toLatex(sessionInfo())
@ 

\bibliographystyle{unsrt}
\bibliography{ExpressionView}

\end{document}
