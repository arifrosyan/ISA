% \VignetteIndexEntry{ExpressionView}
\documentclass{article}
\usepackage{ragged2e}
\usepackage{url}

\newcommand{\Rfunction}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\texttt{#1}}
\newcommand{\Rclass}[1]{\texttt{#1}}
\newcommand{\Rargument}[1]{\textsl{#1}}
\newcommand{\filename}[1]{\texttt{#1}}
\newcommand{\variable}[1]{\texttt{#1}}

\SweaveOpts{cache=TRUE}
\SweaveOpts{prefix.string=graphics/plot}

\begin{document}

\title{Ordering algorithm used in ExpressionView}
\author{Andreas L\"uscher}
\maketitle

\tableofcontents

\RaggedRight

<<set width,echo=FALSE,print=FALSE>>=
options(width=60)
options(continue=" ")
@ 

\section{Introduction}
Clustering genes according to their expression profiles is an important task 
in analyzing microarray data. To present the mutually overlapping biclusters
in a visually appealing layout, the gene expression matrix has to be arranged
in such a way that biclusters form contiguous rectangles. For more than two biclusters,
this is in general impossible. Here, we present an algorithm that finds the arrangement
that maximizes the areas of the largest contiguous parts of the biclusters.

\section{Problem}
The problem can be formulated very generally:
Given a matrix in which each element is part of at least one bicluster, arrange the rows and columns
in such a way that the biclusters are easily recognizable on a two-dimensional graphic.
Since biclusters are rectangular, rows and columns can be ordered separately.
The problem thus reduces to finding the optimal arrangement of a set of $n$ elements 
that are part of at least one of $m$ clusters. 

\section{Quantifying the order}
There are several ways of quantifying a ``visually appealing layout''. We have chosen to
define the quality of the order $Q$ as sum over the maximal number of neighboring elements 
in every cluster
\begin{equation}
Q = \sum_{i=1}^{\text{\# clusters}} {}
\end{equation}

The quality of the order is defined as the sum over the maximal number of neighbouring elements in every cluster and the tasks thus consists in maximizing this quantity by changing the order of the elements. Starting from an initial configuration determined by similarity, this is achieved by either shifting well aligned subsequences of a given cluster, herby enlarging the longest contiguous part, or permuting the individual elements of a given subcluster. 

To determine the efficiency of this method, we have studied a large number of perfectly orderable, but initially scrambled, test cases. We find that in almost every situation, the proposed algorithm finds an order that recovers more than 99\% of the score of the optimal solution and in most cases, it actually recovers the correct alignment. For random samples, which are more representative for actual gene expression data than orderable situations, execution time increases polynomially with the number of clusters $m$ as ${\mathcal O}(m^\alpha)$, where $\alpha \in [1.6, 2]$, almost independent of the number of elements $n$. For a given number of clusters, we find ${\mathcal O}(n^\alpha)$, with $\alpha \in [2.5, 2.7]$.



\section{Optimizing the order}
Optimizing the order thus consists in maximizing this quantity by changing the order
of the elements.


\section{Calculation time}

\begin{figure} 
	\begin{center} 
		\includegraphics{graphics/nclusters.pdf}
	\end{center} 
	\caption{Scaling of the execution time as a function of the number of clusters. Data points connected
	by dashed lines represent results obtained from orderable samples. The second set is obtained
	from random samples and is thus more representative of gene expression data. Both sets scale polynomially
	with the number of clusters $m$ as $\mathcal{O}(m^\alpha)$, with $\alpha \in [1.6, 2]$ for random samples and
	$\alpha \in [2.3, 4.2]$ in the case of orderable samples.} 
	\label{fig:one} 
\end{figure}

\begin{figure} 
	\begin{center} 
		\includegraphics{graphics/nslots.pdf}
	\end{center} 
	\caption{Scaling of the execution time as a function of the number of slots. The second set is obtained
	from random samples and is thus more representative of gene expression data. The random set scales polynomially
	with the number of slots $n$ as $\mathcal{O}(n^\beta)$, with $\beta \in [2.5, 2.7]$. The orderable data set shows an initially
	polynomial increase and then saturates for larger $n$.} 
	\label{fig:one} 
\end{figure}

\bibliographystyle{apalike}
\bibliography{ExpressionView}
\nocite{*}

\end{document}
