\documentclass{article}
\usepackage{ragged2e}
\usepackage{url}

\newcommand{\Rfunction}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\texttt{#1}}
\newcommand{\Rclass}[1]{\texttt{#1}}
\newcommand{\Rargument}[1]{\textsl{#1}}
\newcommand{\filename}[1]{\texttt{#1}}
\newcommand{\variable}[1]{\texttt{#1}}

\SweaveOpts{cache=TRUE}

\begin{document}

\title{The Iterative Signature Algorithm for Gene Expression data}
\author{G\'abor Cs\'ardi}
\maketitle

\tableofcontents

\RaggedRight

\section{Introduction}

The Iterative Signature Algorithm (ISA) is biclustering method. The
input of a biclustering method a matrix and its output is a set of
biclusters that fulfill some criteria; a bicluster is a block of the
potentially reordered input matrix.

Most commonly, this algorithm is used on microarray expression data,
to find gene sets that are coexpressed across a subset of the original
samples. In the original ISA paper the biclusters are called
transription modules (TM), we will often refer them under this name in
the following.

\section{Preparing the data}

\subsection{Loading the data}

First, we load the required packages and the data to analyze. ISA is
implemented in the \Rpackage{eisa} and \Rpackage{isa2} packages, see
Section{sec:isapackages} for a more elaborated summary about the two
packages. It is enough to load the \Rpackage{eisa} package,
\Rpackage{isa2} and other required packages are loaded automatically.
\Rpackage{eisa} 
<<load the packages>>=
library(eisa)
@

In this tutorial we will use the data in the \Rpackage{ALL}
package. 
<<load the data>>=
library(ALL)
library(hgu95av2.db)
library(affy)
data(ALL)
@
This is a data set from a clinical trial in acute
lymphoblastic leukemia and it contains \Sexpr{ncol(ALL)} samples
altogether.

\section{Simple ISA runs}

The simplest way to run ISA is to choose the two threshold parameters
and then call the \Rfunction{isa} function on the
\Rclass{ExpressionSet} object:
<<simple ISA>>=
thr.gene <- 2.7
thr.cond <- 1.4
set.seed(1) # to get the same results, always
modules <- isa(ALL, thr.gene=thr.gene, thr.cond=thr.cond)
@ 

This first applies a non-specific filter to the data set filters the
data set and then runs ISA from
\Sexpr{formals(eisa:::isa.ExpressionSet)$no.seeds} % $
random seeds (the default). See Section~\ref{sec:detailed-isa} if the
default parameters are not appropriate for you and need more control.

\section{Inspect the result}

The \Rfunction{isa} function returns an \Rclass{ISAModules} object. By
typing in its name we can get a brief summary of the results:
<<type in name of ISAModules object>>=
modules
@

There are various other \Rclass{ISAModules} methods that help to
access the modules themselves and the ISA parameters that were used
for the run. 

% TODO: length, dim, featureNames, sampleNames, pData, 
% annotation, organism, indexing

The \Rfunction{getNoFeatures} function returns a numeric vector, the
number of features (probesets in our case) in each module. Similarly,
\Rfunction{getNoSamples} returns a numeric vector, the number of
samples in each module. 
<<number of features and samples>>=
getNoFeatures(modules)
getNoSamples(modules)
@ 

\Rfunction{getFeatureNames} lists the probes (more precisely,
the feature names coming from the \Rclass{ExpressionSet} object) in
the modules. It returns a list, here we just print the first entry in
the list.
<<list genes in modules>>=
getFeatureNames(modules)[[1]]
@

The \Rfunction{getSampleNames} function does the same for the samples.
Again, the sample names are taken from the \Rclass{ExpressionSet}
object that was passed to \Rfunction{isa}:
<<list conditions in modules>>=
getSampleNames(modules)[[1]]
@ 

Remember, that the ISA biclustering is not binary, every feature (and
similarly, every sample) has a score between -1 and 1; the further the
score is from zero the stronger the association between the feature
(or sample) and the module. If two features both have scores with the
same sign, then they are correlated, if the sign of their scores are
opposite, then they are anti-correlated. You can query the scores of
the features with the \Rfunction{getFeatureScores} function, and
similarly, the \Rfunction{getSampleScores} function queries the sample
scores. You can supply the modules you want to query as an optional
argument:
<<query scores>>=
getFeatureScores(modules, 3)
getSampleScores(modules, 3)
@ 

You can also query the scores in a matrix form, that is probably
better if you need many or all of them at the same time. The
\Rfunction{getFeatureMatrix} and \Rfunction{getSampleMatrix} functions
are defined for this:
<<query all scores>>=
dim(getFeatureMatrix(modules))
dim(getSampleMatrix(modules))
@

Objects from the \Rclass{ISAModules} class store various information
about the ISA run and the convergence of the seeds. Information
associated with the individual seeds can be queried with the
\Rfunction{seedData} function, it returns a data frame, with as many
rows as the number of seeds and various seed-level information,
e.g. the number of iterations required for the seed to converge. See
the manual page of \Rfunction{isa} for details.
<<seed data>>=
seedData(modules)
@

The \Rfunction{runData} function returns additional information about
the ISA run, seed the \Rfunction{isa} manual page for details.
<<run data>>=
runData(modules)
@ 

\section{Enrichment calculations}

The \Rpackage{eisa} package provides some functions to perform
enrichment tests for the genes in the various modules against various
databases. These tests are usually simplified and less sophisticated
versions than the ones in the \Rpackage{Category}, \Rpackage{GOstats}
or \Rpackage{topGO} packages, but they are much faster and this is
important if we need to perform them for many modules.

\subsection{Gene Ontology}

To perform enrichment analysis against the Gene Ontology database, all
you have to do is to supply your \Rclass{ISAModules} object to the
\Rfunction{isa.GO} function.
<<GO enrichment>>=
GO <- isa.GO(modules)
@ 

The \Rfunction{isa.GO} requires an annotation package that maps the
Entrez identifiers of the studied organism to GO terms. For human, the
\Rpackage{org.Hs.eg.db} package is required, for the mouse the
\Rpackage{org.Mm.eg.db} package, etc.

The \variable{GO} object is a list with three elements, these
correspond to the ontologies: biological function, cellular component
and molecular function, in this order.
<<list GO result>>=
GO
@

We can see the number of categories tested, this is different for each
ontology, as they have different number of terms. The gene universe
size is also different, because it contains only genes that have at
least one annotation in the given category.

For extracting the results themselves, the \Rfunction{summary}
function can be used, this converts them to a simple data frame. The
$p$-value limit can be supplied to \Rfunction{summary}. Note, that
since \Rfunction{isa.GO} calculates enrichment for many gene sets
(i.e. for all biclusters), \Rfunction{summary} returns a list of data
frames, one for each bicluster. A table for the first module:
<<GO summary>>=
summary(GO[[1]], p=0.001)[[1]]
@ 

The \texttt{drive} column includes the Entrez ids of the genes that
are included in the intersection of the bicluster and the GO
category. They can be also obtained with the
\Rfunction{geneIdsByCategory} function. The following returns the
genes in the first module and the second GO BP category.
<<GO gene ids by category>>=
geneIdsByCategory(GO[[1]])[[1]][[2]]
@ 

You can use the \Rpackage{GO.db} package to obtain more information
about the enriched GO categories.
<<GO info>>=
sigCategories(GO[[1]])[[1]]
library(GO.db)
mget(sigCategories(GO[[1]])[[1]], GOTERM)
@ 

In addition, the following functions are implemented to work on the
objects returned by \Rfunction{isa.GO}: \Rfunction{htmlReport},
\Rfunction{pvalues}, \Rfunction{geneCounts}, \Rfunction{oddsRatios},
\Rfunction{exprectedCounts}, \Rfunction{universeCounts},
\Rfunction{universeMappedCount}, \Rfunction{geneMappedCount},
\Rfunction{geneIdUniverse}. These functions do essentially the same as
they counterparts for \Rclass{GOHyperGResult} objects, see the
documentation of the \Rpackage{GOstats} package. The only difference
is, that since here we are testing a list of gene sets (=biclusters),
they calculate the results for all gene sets and return a list.

\subsubsection{Multiple testing correction}

By default, the \Rfunction{isa.GO} function performs multiple testing
correction using the Holm method, this can be changed via the
\texttt{correction} and \texttt{correction.method} arguments. See the
manual page of the \Rfunction{p.adjust} function for the possible
multiple testing correction schemes.

\subsection{KEGG Pathway Database}

Enrichment calculation against the KEGG pathway goes essentially the
same way as for the Gene Ontology, this time we use the
\Rfunction{isa.KEGG} function:
<<KEGG enrichment>>=
KEGG <- isa.KEGG(modules)
KEGG
summary(KEGG)[[1]]
library(KEGG.db)
mget(sigCategories(KEGG)[[1]], KEGGPATHID2NAME)
@

The functions mentioned in the Gene ontology enrichment section can be
used for KEGG, as well.

\subsection{Chromosomes}

The \Rpackage{eisa} includes a simple way to check whether the genes
in a bicluster are associated with a chromosome. See the
\Rfunction{isa.CHR} function:
<<CHR enrichment>>=
CHR <- isa.CHR(modules)
summary(CHR,p=0.05)[[11]]
@ 

The third bicluster has \Sexpr{summary(CHR,p=0.05)[[2]]$Count[1]} % $
genes on chromosome \Sexpr{rownames(summary(CHR,p=0.05)[[2]])[1]}.

The functions mentioned in the Gene ontology enrichment section can be
used for chromosome enrichment, as well.

\subsection{Predicted $\mu$RNA targets 
  from the TargetScan database}

$\mu$RNAs are short RNA molecules that regulate gene expression.
TargetScan is a data based of predicted target genes of $\mu$RNAs, for
severral organisms. There are two R packages that incorporate this
database, one for human and another one for mouse, right now they can
be downloaded from
\url{http://www2.unil.ch/cbg/index.php?title=Building_BioConductor_Annotation_Packages}.
The \Rpackage{targetscan.Hs.eg.db} package is for human, the
\Rpackage{targetscan.Mm.eg.db} package is for mouse.

The enrichment calculation itself is basically the same as for GO and
KEGG, but the \Rfunction{isa.miRNA} function should be used:
<<miRNA enrichment>>=
if (require(targetscan.Hs.eg.db)) {
  miRNA <- isa.miRNA(modules)
  summary(miRNA, p=1)[[7]]
}
@ 

%\subsection{Transcription regulation from the DBD database}

%TODO

\section{Visualizing the results}

Visualizing overlapping biclusters is a challenging task. We
show simple methods that usually visualize a single bicluster 
at a time. For some of these we will use the \Rpackage{biclust} R
package.

\subsection{The \Rpackage{biclust} package}

The \Rpackage{biclust} R package implements several biclustering
algorithms in a unified framework. It uses the class \Rclass{Biclust}
to store a set of biclusters. The \Rfunction{eisa.biclust} converts ISA
modules to a \Rclass{Biclust} object. This requires the binarization
of the modules, i.e. the ISA scores are lost, they are converted to
zeros and ones:
<<biclust,cache=TRUE>>=
library(biclust)
Bc <- eisa.biclust(modules)
Bc
@ 

\subsection{Image plots}

The easiest way to create a heatmap of a single module is to call the
\Rfunction{ISA2heatmap} function. You need to specify which module you
want to plot and also the \Rclass{ExpressionSet} object that is being
analyzed. Note that by default ISA normalizes the expression data
before running the module detection; the raw, non-normalized values
are plotted in the next example. If you want to plot the normalized
values, then you need to do the normalization ``by hand'', before
calling ISA, see Section~\ref{sec:detailed-isa}.
<<heatmap,fig=TRUE>>=
ISA2heatmap(modules, 1, ALL)
@ 

\Rfunction{ISA2heatmap} simply calls the \Rfunction{heatmap} function,
and passes additional arguments to it. See the manual of
\Rfunction{heatmap} for details.

You can also use the \Rpackage{biclust} package to create image
plots, by calling the \Rfunction{drawHeatmap} function. The result is
in Fig.~\ref{fig:drawHeatmap}.
<<heatmap biclust pre,echo=FALSE,results=hide>>=
CairoPNG("heatmap.png", 400, 400 )
@ 
<<heatmap>>=
drawHeatmap(exprs(ALL), Bc, number=1) 
@
<<heatmap post,echo=FALSE,results=hide>>=
dev.off() 
@ 
\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{heatmap}
  \caption{TODO}
  \label{fig:drawHeatmap}
\end{figure}

\subsection{Profile plots}

Profile plots visualize the difference between the genes (or samples)
in the modules and the rest of the expression data. A profile plot
contains a line plot for every single gene (or sample) and the genes
that belong to the module have a different color, see
Fig.~\ref{fig:parallel}.
<<parallel.pre,echo=FALSE,results=hide>>=
CairoPNG("parallel.png", 400, 400 )
@ 
<<parallel>>=
parallelCoordinates(exprs(ALL), Bc, number=1, plotBoth=TRUE, pch=NA)
@
<<parallel.post,echo=FALSE,results=hide>>=
dev.off()
@ 
\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{parallel}
\caption{Profile plots for the first bicluster found by ISA.}
\label{fig:parallel}
\end{figure}

\subsection{Gene ontology tree plots}

The GO database is organized in a hierarchical fashion, in a tree-like
structure, where the broadest category sits in the root of the tree
and broader categories are subdivided into more specific
subcategories. But the GO is not exactly a tree, as the same category
can be the subcategory of more than one broader categories: e.g. the
``Golgi vesicle transport'' category is part of both
``vesicle-mediated transport'' and ``intracellular
transport''.

The \Rpackage{eisa} package provides some functions to plot parts of
the GO graph that is related to a transcription module. The
\Rfunction{gograph} function creates an object that is a
representation of such a plot. Its input is a table with the GO
categories to plot and their enrichment $p$-values. (Additional
columns are silently ignored.) Here is how to use
it on the previously calculated enrichment scores:
<<goplot1>>=
goplot.2 <- gograph(summary(GO[[1]], p=0.05)[[2]])
@ 

\Rfunction{goplot} uses the \Rpackage{igraph} package to create a
graph with associated meta data:
<<gograph object>>=
summary(goplot.2)
@ 
The \texttt{width} and \texttt{height} graph attributes contain the
suggested width and height of the graph, if plotted to a bitmap
device. (The graph attributes of an \Rpackage{igraph} graph can be
queried with the `\texttt{\$}' selector:
<<gograph object 2>>=
goplot.2$width
goplot.2$height
@

Let's plot the graph, we can do this with the \Rfunction{gograph.plot}
function.
<<goplot2,eval=FALSE>>=
x11(width=10, height=10*goplot.2$height/goplot.2$width)
gograph.plot(goplot.2)
@
\setkeys{Gin}{width=\textwidth}
<<goplot2-real,echo=FALSE,width=10,height=2.5,fig=TRUE>>=
ps.options(fonts=c("serif", "mono"))
gograph.plot(goplot.2)
@ 

Because the GO is not really a tree, \Rfunction{gograph} ``unfolds''
it into a tree by including categories more than once, if needed. It
also abbreviates the names of the GO categories to make them fit on
the tree. The graph object contains the full name of the category as
well. The full and abbreviated names can be listed by querying the
appropriate vertex attributes of the graph. Here they are for the
first five categories:
<<goplot names>>=
V(goplot.2)$abbrv[1:5]
lapply(V(goplot.2)$desc[1:5], strwrap)
@ 
\Rfunction{gograph.plot} colors the categories according to the
supplied enrichment $p$-values, the minus $\log_{10}$ $p$-value is
also added to the plot, see the bold blue numbers.

\subsection{Sample score plots}

In many studies, especially the case-control ones, it is useful to
plot the sample scores of a module. For example if the sample scores
significantly differ for two groups of samples (e.g. cases versus
controls), then the genes in the module can be used as discriminators
between the two groups.

The \Rfunction{cond.plot} function can plot the sample scores,
potentially including the scores before the ISA filtering. Let us plot
the scores for the second module, the color code denotes B-cell
vs. T-cell leukemia.

<<condplot,fig=TRUE,width=10,height=4>>=
col <- ifelse( grepl("^B", pData(modules)$BT), "orange", "darkolivegreen")
cond.plot(modules, 2, ALL, col=col)
@

It is clear that the \Sexpr{getNoFeatures(modules)[2]} genes included
in this transcription module can separate B-cell and T-cell leukemia
samples.

\subsection{Generating a HTML summary for the modules}

\section{How ISA works}

Before showing an actual ISA tool chain, a few words about how the
algorithm works are in order.

\subsection{ISA iteration}

ISA works in an iterative way. For an $E (m\times n)$
input matrix it starts from a seed vector $r_0$, which is
typically a sparse 0/1 vector of length $m$. The non-zero elements in
the seed vector define a set of genes in $E$. Then the transposed of
$E$, $E'$ is multiplied by $r_0$ and the result is thresholded.

The thresholding is an important step of the ISA, without thresholding
ISA would be equivalent to a (not too effective) numerical singular
value decomposition (SVD) algorithm. Currently thresholding is done by
calculating the mean and standard deviation of the vector and keeping
only elements that are further than a given number of standard
deviations from the mean. Based on the \Rargument{direction} parameter,
this means keeping values that are significantly higher than the
mean (``\emph{up}''), or keeping the ones that are significantly lower
than the mean (``\emph{down}''); or keeping both
(``\emph{updown}'').

The thresholded vector $c_0$ is the (sample)
\emph{signature} of $r_0$. Then the (gene) signature of
$c_0$ is calculated, $E$ is multiplied by $c_0$ and then thresholded
to get $r_1$.

This iteration is performed until it converges, i.e. $r_{i-1}$
and $r_i$ are \emph{close}, and $c_{i-1}$ and
$c_i$ are also close. The convergence criteria,
i.e. what \emph{close} means, is by default defined by high Pearson
correlation.

It is very possible that the ISA finds the same module more than once;
two or more seeds might converge to the same module. The function
\Rfunction{isa.unique} eliminates every module from the result of 
\Rfunction{isa.iterate} that is very similar (in terms of
Pearson correlation) to the one that was already found before.

It might be also apparent from the description of ISA, that the
biclusters are soft, i.e. they might have an overlap in their genes,
samples, or both. It is also possible that some genes and/or
samples of the input matrix are not found to be part of any ISA
biclusters. Depending on the stringency parameters in the
thresholding (i.e. how far the values should be from the mean), it
might even happen that ISA does not find any biclusters.

\subsection{Parameters}

The two main parameters of ISA are the two thresholds (one for the
genes and one for the samples). They basically define the stringency of
the modules. If the gene threshold is high, then the modules will have
very similar genes. If it is mild, then modules will be bigger, with
less similar genes than in the first case. The same applies to the
sample threshold and the samples of the modules.

\subsection{Random seeding and smart seeding}

By default (i.e. if the \Rfunction{isa} function is used) the ISA is
performed from random sparse starting seeds, generated by the
\Rfunction{generate.seeds} function. This way the algorithm is 
completely unsupervised, but also stochastic: it might give different
results for different runs.

It is possible to use non-random seeds as well. If you have some
knowledge about the data or are interested in a particular subset of
genes/samples, then you can feed in your seeds into the
\Rfunction{isa.iterate} function directly. In this case the
algorithm is deterministic, for the same seed you will always get the
same results. Using smart (i.e. non-random) seeds can be considered as
a semi-supervised approach. 

\subsection{Normalization}

Using in silico data we observed that ISA has the best performance if the
input matrix is normalized (see \Rfunction{isa.normalize}). The
normalization produces two matrices: $E_r$ and
$E_c$. $E_r$ is calculated by transposing $E$ and
centering and scaling its genes (see the \Rfunction{scale} R function). $E_c$ is
calculated by centering and scaling the genes of $E$. $E_r$ is
used to calculate the sample signature of genes and $E_c$ is used
to calculate the signature of the samples.

It is possible to use another normalization. In this case the user is
requested to supply the normalized input data in a named list,
including the two matrices of appropriate
dimensions to the \Rfunction{isa.iterate} function.

The \texttt{Er} entry of the list will be used for calculating the
signature of the genes, \texttt{Ec} will be used for the signature of the
samples. If you want to use the same matrix in both steps, then supply
it twice, the first one transposed.

\subsection{Gene and sample scores}

In addition to finding biclusters in the input matrix, the ISA also
assigns scores to the genes and samples, separately for each
module. The scores are between minus one and one and they are by
definition zero for the genes/samples that are not included in the
module. For the non-zero entries, the further the score of a
gene/samples is from zero, the stronger the association between the
gene/sample and the module. If the sign of two genes/samples are the
same, then they are correlated, if they have opposite signs, then they
are anti-correlated. 

\section{Bicluster coherence and robustness measures}

\subsection{Coherence}

Madeira and Oliviera\cite{madeira04} define various coherence scores
for biclusters, these measure how well the rows and or columns are
correlated. It is possible to use these measures for ISA as well,
after converting the output of ISA to a \Rclass{biclust} object. 
Here are the measures for the first bicluster:
<<coherence>>=
constantVariance(exprs(ALL), Bc, number=1)
additiveVariance(exprs(ALL), Bc, number=1)
multiplicativeVariance(exprs(ALL), Bc, number=1)
signVariance(exprs(ALL), Bc, number=1)
@

You can use \Rfunction{sapply} to perform the calculation for many or
all modules, e.g. for this data set `constant variance' and `additive
variance' are not the same:
<<coherence all>>=
cv <- sapply(seq_len(Bc@Number), 
             function(x) constantVariance(exprs(ALL), Bc, number=x))
av <- sapply(seq_len(Bc@Number), 
             function(x) additiveVariance(exprs(ALL), Bc, number=x))
cor(av, cv)
@
Please see the manual pages of these functions and the paper cited
above for more details.

\subsection{Robustness}

The \Rpackage{eisa} package uses a measure that is related to
coherence; it is called robustness. Robustness is a generalization of
the singular value of a matrix. If there were no thresholding during
the ISA iteration, then ISA would be equivalent to a numerical method
for singular value decomposition and robustness would be indeed the
same the principal singular value of the input matrix. 

If the \Rfunction{isa} function was used to find the transcription
modules, then the robustness measure is used to filter the results.
This is done by first scrambling the input matrix and then running ISA
on it. As ISA is an unsupervised algorithm it usually finds some
(although less and smaller) modules even in such a scrambled data
set. Then the robustness scores are calculated for the proper and the
scrambled modules and only (proper) modules that have a higher score
than the highest scrambled module are kept. The robustness scores are
stored in the seed data during this process, so you can check them
later:
<<robustness>>=
seedData(modules)$rob
@

\section{The \Rpackage{isa2} and \Rpackage{eisa} packages}%
\label{sec:isapackages}

ISA and its companion functions for visualization, functional
enrichment calculation, etc. are distributed in two separate packages,
\Rpackage{isa2} and \Rpackage{eisa}.

\Rpackage{isa2} contains the implementation of ISA itself, and
\Rpackage{eisa} specifically deals with supplying expression data to
\Rpackage{isa2} and visualizing the results.

The two packages provide some functions that share the same name, and
the right one is selected based on the arguments supplied. E.g. both
\Rpackage{isa2} and \Rpackage{eisa} has a function called
\Rfunction{isa}. It the first argument of \Rfunction{isa} is an
\Rclass{ExpressionSet}, then the \Rpackage{eisa} version is called. If
the first argument is a matrix, then the \Rpackage{isa} version is
called.

This also means that there are two manual pages for the two
\Rfunction{isa} functions. I.e. if one types `\verb+?isa+', (and both
\Rpackage{isa2} and \Rpackage{eisa} are loaded, then one
has to choose between the two versions. To avoid this, the
\Rpackage{eisa} manual pages can also be referenced by supplying and
`\verb+e+' prefix: `\verb+?eisa+' or `\verb+?eisa.unique+'.

\section{Finer control over ISA parameters}%
\label{sec:detailed-isa}

\section{Session information}

The version number of R and packages loaded for generating this
vignette were:

<<sessioninfo,results=tex,echo=FALSE>>=
toLatex(sessionInfo())
@ 

\bibliographystyle{apalike}
\bibliography{EISA}
\nocite{*}

\end{document}
